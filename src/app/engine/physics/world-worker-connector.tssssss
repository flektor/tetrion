import { Vector3, Quaternion, Mesh, Vector4, BufferGeometry, Object3D } from 'three';
import { Brick } from '../engine/brick';
import { GameStatus } from '../services/game/game.interface'; 
import { IWorld, CylinderInstructions, BoardInstructions } from './IWorld';

export class WorldWorkerConnector implements IWorld {

  private worker: Worker;
  private dt: number = 1 / 60;
  private lastTime: number;

  // private meshes: Array<Mesh | Brick> = new Array();
  private bricks: Array<Brick> = new Array();

  // private staticMeshes: Array<Mesh> = new Array();
  // private staticBodiesCount: number = 0;
  public bodiesCount: number = 0;

  private positions: SharedArrayBuffer;
  private quaternions: SharedArrayBuffer;

  private lastUsedBufferIndex: number = -1;
  private unusedBufferIndices: Array<number> = new Array();

init(){}

  constructor(private rows: number, private cols: number) {

    if (typeof Worker !== 'undefined') {
      const positionsLength = cols * rows * 3 * 4;
      this.positions = new SharedArrayBuffer(positionsLength);// cols * 4rows * 3(xyz values) * 4 bytes
      this.quaternions = new SharedArrayBuffer(cols * rows * 4 * 4);// cols * 4rows * 4(xyzw values) * 4 bytes
      const offsetx = cols / 2;
      for (let i = 1; i < positionsLength; i += 3) {
        this.positions[i - 1] = offsetx;
        this.positions[i] = -0.5;
      }

      this.worker = new Worker('world.worker.js');

      this.worker.addEventListener('message', e => {

        if (!e.data.task || e.data.task !== 'updateResponse') {
          return console.log("Unnexpected data: " + e.data);
        }

        // Get fresh data from the worker
        const positions = new Float32Array(this.positions);
        const quaternions = new Float32Array(this.quaternions);

        // Update rendering meshes
        for (let brick of this.bricks) {
          let i = brick.bufferIndex * 3;

          brick.position.set(
            positions[i] + this.cols / 2,
            // positions[i] + this.cols / 2,
            positions[i + 1],
            positions[i + 2]
          );
          i += brick.bufferIndex;
          brick.quaternion.set(
            quaternions[i],
            quaternions[i + 1],
            quaternions[i + 2],
            quaternions[i + 3]
          );
        }

        // // If the worker was faster than the time step (dt seconds), we want to delay the next timestep
        // let delay = this.dt * 1000 - (Date.now() - this.lastTime);
        // if (delay < 0) {
        //   delay = 0;
        // }
        // setTimeout(() => this.update(), delay);

      });

      // start
      this.worker.postMessage({
        task: 'initWorld',
        dt: this.dt,
        positions: this.positions,
        quaternions: this.quaternions,
        rows: rows,
        cols: cols
      });

    } else {
      console.log("Web Workers are not supported in this environment.");
      console.log("You should add a fallback so that your program still executes correctly.");
    }
  }

  public update(): number {
    const time = Date.now();
    const lastTime = this.lastTime;
    this.lastTime = time;
    if (lastTime === undefined) return 0;

    this.dt = (time - lastTime) / 1000;

    if (this.bricks.length > 0) {
      this.worker.postMessage({
        task: 'updateRequest',
        dt: this.dt
      });
    }
    return this.dt;
  }

  public setVelocity(brick: Brick, velocity: Vector3): void {
    this.worker.postMessage({
      task: 'setVelocity',
      index: this.bricks.indexOf(brick),
      velocity: velocity
    });
  }

  public setGravity(gravity: Vector3): void {
    this.worker.postMessage({
      task: 'setGravity',
      gravity: gravity
    });
  }

  public setGameOver(isTrue: boolean): void {
    this.worker.postMessage({
      task: 'setGameOver',
      isGameOver: isTrue
    });
    this.setGravity(new Vector3())
  }

  public addBrick(brick: Brick): void {
    if (this.unusedBufferIndices.length > 0) {
      brick.bufferIndex = this.unusedBufferIndices[0];
      this.unusedBufferIndices.splice(0, 1);
    } else {
      brick.bufferIndex = ++this.lastUsedBufferIndex;
    }

    this.worker.postMessage({
      task: 'addBrick',
      bufferIndex: brick.bufferIndex,
      params: {
        position: brick.position,
        quaternion: new Vector4().setAxisAngleFromQuaternion(brick.quaternion)
      }
    });

    this.bricks.push(brick);
    this.bodiesCount++;
  }

  public explodeBrick(brick: Brick) {
    this.worker.postMessage({
      task: 'explodeBrick',
      index: this.bricks.indexOf(brick)
    });
  }

  public applyImpulse(params: ApplyImpulseParams): void {
    this.worker.postMessage({
      task: 'applyImpulse',
      index: this.bricks.indexOf(params.brick),
      impulse: params.impulse,
      worldPoint: params.worldPoint
    });
  }

  public removeBrick(brick: Brick): void {
    const index = this.bricks.indexOf(brick);
    if (index < 0) return;

    this.worker.postMessage({
      task: 'remove',
      index: index
    });
    this.bricks.splice(index, 1);
    this.bodiesCount--;

    this.unusedBufferIndices.push(brick.bufferIndex);
  }

  public setPosition(index: number, position: Vector3): void {
    this.worker.postMessage({
      task: 'setPosition',
      index: index,
      position: position
    });
    this.bricks[index].position.copy(position);
  }

  public setQuaternion(index: number, quaternion: Quaternion): void {
    console.log(quaternion)
    this.worker.postMessage({
      task: 'setQuaternion',
      index: index,
      quaternion: quaternion
    });
    this.bricks[index].quaternion.copy(quaternion as Quaternion);
  }

  public setBoard(instructions: BoardInstructions): void {
    this.rows = instructions.rows;
    this.cols = instructions.cols;

    this.worker.postMessage({
      task: 'setBoard',
      instructions: {
        rows: instructions.rows,
        cols: instructions.cols,
        bottom: {
          position: instructions.bottom.position,
          quaternion: new Vector4().setAxisAngleFromQuaternion(instructions.bottom.quaternion as any),

          scale: instructions.bottom.scale
        },
        left: {
          position: instructions.left.position,
          quaternion: new Vector4().setAxisAngleFromQuaternion(instructions.left.quaternion as any),
          scale: instructions.left.scale
        },
        right: {
          position: instructions.right.position,
          quaternion: new Vector4().setAxisAngleFromQuaternion(instructions.right.quaternion as any),

          scale: instructions.right.scale
        },
      }
    });
    this.bodiesCount++;
  }

  public setStatus(status: GameStatus) {
    this.worker.postMessage({
      task: 'setStatus',
      status: status
    });
    this.bodiesCount++;
  }

  public setStaticDropRowPlane(position: Vector3) {
    this.worker.postMessage({
      task: 'setStaticDropRowPlane',
      position: position
    });
  }

  public resetStaticDropRowPlanes() {
    this.worker.postMessage({
      task: 'resetStaticDropRowPlanes',
    });
  }

  public addRigitBody(object: Object3D, mass: number) {
    const instructions = new Array();

    for (let mesh of object.children) {
      instructions.push({
        vertices: (((mesh as Mesh).geometry as BufferGeometry).attributes.position || {}).array || [],
        mass: mass
      })

    }

    this.worker.postMessage({
      task: 'addBodyRigit',
      instructions: instructions,
    });
    this.bodiesCount++;
  }

  public addCylinder(instructions: CylinderInstructions) {
 
    this.worker.postMessage({
      task: 'addCylinder',
      instructions: {
        position: instructions.position,
        quaternion: new Vector4().setAxisAngleFromQuaternion(instructions.quaternion),
 
        radiusBottom: instructions.radiusBottom,
        radiusTop: instructions.radiusTop,
        height: instructions.height,
        mass: instructions.mass,
        numSegments: instructions.numSegments
      }
    });
  }

}

export interface ApplyImpulseParams {
  brick: Brick,
  impulse: Vector3,
  worldPoint: Vector3
}


  // addBodyRigit(verts: number[], faces: number[], offset: number[], mass: number) {
  //   this.worker.postMessage({
  //     task: 'addBodyRigit',
  //     faces: faces,
  //     verts: verts,
  //     offset: offset,
  //     mass: mass
  //   });
  // }

  // public addContactMaterial(material: ContactMaterial): void {
  //   this.worker.postMessage({
  //     task: 'addContactMaterial',a
  //     material: material
  //   });
  // }

  // public addStaticPlane(instructions: StaticPlaneInstractions) {
  //   this.worker.postMessage({
  //     task: 'addStaticPlane',
  //     instructions: instructions
  //   });
  //   if (instructions.mesh) {
  //     this.staticMeshes.push(instructions.mesh)
  //   }
  //   this.bodiesCount++;
  // }

  // public rename(brick: Brick, name: string): void {
  //   this.worker.postMessage({
  //     task: 'rename',
  //     index: this.bricks.indexOf(brick),
  //     name: name
  //   });
  // }
